cm <- function(x) {
# A partir de la semilla x, se genera una sucesión de valores,
# tomando los valores de enmedio de la serie
u <- x/10^nchar(as.character(x)) # primer uniforme
z <- x # copia de trabajo
repeat{
# verifica que el número tenga suficientes dígitos
z <- z^2
n <- nchar(z)
if (n < 6) break
# partiendo de un tamaño de 7 dígitos, escogemos los dígitos centrales y vamos recorriendo
z <- as.numeric(as.character(substr(z, n-5, n-2)))
u <- append(u, z/10000)
if ((u[length(u)] == 0 ) | length(unique(u)) < length(u)) break #si el último número es 0 o ya se repiten termina
}
return(u)
}
# converge rápido a 0:
cm(1009)
# ciclos cortos:
cm(898775)
z0 <- 5675431
u <- cm(z0)
u
J <- seq(556734, 1000000, by = 100)
i <- NULL
for (j in J) i[match(j,J)] <- length(cm(j))
head(i,20)
max(i)
library(plot3D)
install.packages(c("plot3D","animation"))
install.packages(c("plot3D","animation"))
library(plot3D)
library(animation)
lcg.poor <- function(n){
# http://www.aaronschlegel.com/linear-congruential-generator-r/
rng <- vector(length=n)
m <- 2048
a <- 1229
c <- 1
d <- as.numeric(Sys.time())*1000 #genera una semilla del reloj de la compu
for (i in 1:n){
d <- (a*d+c) %% m
rng[i] <- d/m
}
return(rng)
}
n <- c(3,10,20,100,500,1000,2000,5000,10000,20000)
#saveGIF({
for (i in 1:length(n)){
x <- lcg.poor(n[i])
y <- lcg.poor(n[i])
z <- lcg.poor(n[i])
scatter3D(x,y,z, colvar = NULL, pch=20, cex=0.5,
theta = 20,
main =paste("n= ",n[i]))
}
#}, movie.name="lcg_poor.gif")
install.packages(c("plot3D","animation"))
library(plot3D)
library(animation)
lcg.poor <- function(n){
# http://www.aaronschlegel.com/linear-congruential-generator-r/
rng <- vector(length=n)
m <- 2048
a <- 1229
c <- 1
d <- as.numeric(Sys.time())*1000 #genera una semilla del reloj de la compu
for (i in 1:n){
d <- (a*d+c) %% m
rng[i] <- d/m
}
return(rng)
}
n <- c(3,10,20,100,500,1000,2000,5000,10000,20000)
saveGIF({
for (i in 1:length(n)){
x <- lcg.poor(n[i])
y <- lcg.poor(n[i])
z <- lcg.poor(n[i])
scatter3D(x,y,z, colvar = NULL, pch=20, cex=0.5,
theta = 20,
main =paste("n= ",n[i]))
}
}, movie.name="lcg_poor.gif")
install.packages(c("plot3D","animation"))
library(plot3D)
library(animation)
lcg.poor <- function(n){
# http://www.aaronschlegel.com/linear-congruential-generator-r/
rng <- vector(length=n)
m <- 2048
a <- 1229
c <- 1
d <- as.numeric(Sys.time())*1000 #genera una semilla del reloj de la compu
for (i in 1:n){
d <- (a*d+c) %% m
rng[i] <- d/m
}
return(rng)
}
n <- c(3,10,20,100,500,1000,2000,5000,10000,20000)
saveGIF({
for (i in 1:length(n)){
x <- lcg.poor(n[i])
y <- lcg.poor(n[i])
z <- lcg.poor(n[i])
scatter3D(x,y,z, colvar = NULL, pch=20, cex=0.5,
theta = 20,
main =paste("n= ",n[i]))
}
}, movie.name="lcg_poor.gif")
install.packages(c("plot3D", "animation"))
#install.packages(c("plot3D","animation"))
library(plot3D)
library(animation)
lcg.poor <- function(n){
# http://www.aaronschlegel.com/linear-congruential-generator-r/
rng <- vector(length=n)
m <- 2048
a <- 1229
c <- 1
d <- as.numeric(Sys.time())*1000 #genera una semilla del reloj de la compu
for (i in 1:n){
d <- (a*d+c) %% m
rng[i] <- d/m
}
return(rng)
}
n <- c(3,10,20,100,500,1000,2000,5000,10000,20000)
saveGIF({
for (i in 1:length(n)){
x <- lcg.poor(n[i])
y <- lcg.poor(n[i])
z <- lcg.poor(n[i])
scatter3D(x,y,z, colvar = NULL, pch=20, cex=0.5,
theta = 20,
main =paste("n= ",n[i]))
}
}, movie.name="lcg_poor.gif")
#install.packages(c("plot3D","animation"))
library(plot3D)
library(animation)
lcg.poor <- function(n){
# http://www.aaronschlegel.com/linear-congruential-generator-r/
rng <- vector(length=n)
m <- 2048
a <- 1229
c <- 1
d <- as.numeric(Sys.time())*1000 #genera una semilla del reloj de la compu
for (i in 1:n){
d <- (a*d+c) %% m
rng[i] <- d/m
}
return(rng)
}
n <- c(3,10,20,100,500,1000,2000,5000,10000,20000)
#saveGIF({
for (i in 1:length(n)){
x <- lcg.poor(n[i])
y <- lcg.poor(n[i])
z <- lcg.poor(n[i])
scatter3D(x,y,z, colvar = NULL, pch=20, cex=0.5,
theta = 20,
main =paste("n= ",n[i]))
}
#}, movie.name="lcg_poor.gif")
lgc  <- function(m=16,a=5,c=3,z0=7,graf=T) {
#esta función genera un lgc hasta que alcanza su periodo
z <- z0
i <- 1
repeat {
i <- i+1
z[i] <- (a*z[i-1] + c) %% m
if(i>m) break
}
if (graf){
par(pty="s")
plot(z[2:(m+1)]/m, z[1:m]/m,
xlab = "u[i]", ylab = "u[i-1]", main =
paste0("Generador congruencial m=",m,", a=",a,", c=",c))
}
return(z/m)
}
z <- lgc(m=32,a=5,c=3)
set.seed(10)
runif(5)
runif(5)
set.seed(10)
runif(5)
runif(5)
library(rngWELL)
install.packages(c("rngWELL", "randtoolbox"))
#install.packages(c("rngWELL", "randtoolbox"))
library(rngWELL)
library(randtoolbox)
congruRand(10, mod=2^31-1, mult = 16807, incr = 0)
install.packages(c("rgl", "plot3D"))
install.packages(c("rgl", "plot3D"))
#install.packages(c("rgl", "plot3D"))
library(rgl) # visualización en 3D. Requiere R 3.5.1 o mayor
library(plot3D)
#RANDU:
x <- congruRand(1200,mod = 2^31, mult = 2^16 +3, incr = 0)
library(randtoolbox)
#install.packages(c("rngWELL", "randtoolbox"))
library(rngWELL)
library(randtoolbox)
#install.packages(c("rgl", "plot3D"))
library(rgl) # visualización en 3D. Requiere R 3.5.1 o mayor
library(plot3D)
#RANDU:
x <- congruRand(1200,mod = 2^31, mult = 2^16 +3, incr = 0)
plot3d(matrix(x,ncol=3,byrow=T))
